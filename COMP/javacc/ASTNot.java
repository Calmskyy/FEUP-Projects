/* Generated By:JJTree: Do not edit this line. ASTNot.java Version 6.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.ArrayList;
public
class ASTNot extends SimpleNode {
  public ASTNot(int id) {
    super(id);
  }

  public ASTNot(Jmm p, int id) {
    super(p, id);
  }

  @Override
  public void analyzeSemantics(ArrayList<SymbolTable> symbolTables, ArrayList<String> errors){

    for(int i = 0; i < this.jjtGetNumChildren(); i++){
      
      this.jjtGetChild(i).setMethod(this.getMethod());
      this.jjtGetChild(i).analyzeSemantics(symbolTables, errors);

    }

    SymbolTable st = null;
      for (int i = 0; i < symbolTables.size(); i++) {
        if (symbolTables.get(i).getName().equals(this.getMethod())) 
          st = symbolTables.get(i);
      }
    if (st == null)
        return;
    SimpleNode operand = (SimpleNode) this.jjtGetChild(0);
    String operand_name = "";
    String operand_type = "";
    if (operand.toString() == "Identifier") {
      boolean operand_init = true;
      operand_name = operand.getVal();
      if (!st.hasVariable(operand_name)) {
          boolean missingVariable = true;
          for(int i = 0; i < symbolTables.size(); i++) { //checking if it's a field variable
            if(symbolTables.get(i).getClassSpecific()) {
              if(symbolTables.get(i).hasVariable(operand_name)){
                missingVariable = false;
                operand_type = symbolTables.get(i).getType(operand_name);
                operand_init = symbolTables.get(i).getInit(operand_name);
              }
            }
          }
          if (missingVariable) {
            errors.add("ERROR: Not operator is used on a variable that does not exist: " + operand_name + ".");
            return;
          }
      }
      else {
        operand_type = st.getType(operand_name);
        operand_init = st.getInit(operand_name);
      }
      if (operand_init == false)
        errors.add("ERROR: Not operator is used on an uninitialized variable: " + operand_name + ".");
      if (operand_type != "Boolean")
        errors.add("ERROR: Not operator is used on a non-boolean variable: " + operand_name + ".");
      return;
    }
    if (operand.toString() == "Expression") {
      return;
    }
    if (operand.toString() == "Value") {
      if (!(operand.getVal().equals("true") || operand.getVal().equals("false")))
        errors.add("ERROR: Not operator is used on a non-boolean value: " + operand.getVal() + ".");
      return;
    }
    if (operand.toString() == "Not") {
      return;
    }
    if (operand.toString() == "Less") {
      return;
    }
    if (operand.toString() == "And") {
      return;
    }
    if (operand.toString() == "Sum" || operand.toString() == "Sub" || operand.toString() == "Mult" || operand.toString() == "Div") {
      boolean lessFound = false;
      for (int i = 1; i < this.jjtGetNumChildren(); i++) {
        SimpleNode next_child = (SimpleNode) this.jjtGetChild(i);
        if (next_child.toString().equals("Sum") || next_child.toString().equals("Sub") || next_child.toString().equals("Mult") || next_child.toString().equals("Div") || next_child.toString().equals("Dot"))
          continue;
        if (next_child.toString().equals("Less")) {
          lessFound = true;
          break;
        }
      }
      errors.add("ERROR: Not operator cannot be used on an arithmetic operation.");
      return;
    }
    if (operand.toString() == "Dot") {
      errors.add("ERROR: Not operator is not used on a boolean expression.");
      return;
    }
    if (operand.toString() == "FunctionCall") {
      SimpleNode second_child = (SimpleNode) operand.jjtGetChild(1);
      if (second_child.toString() == "Identifier") {
        String child_name = second_child.getVal();
        String method_type = "";
        for (int i = 0; i < symbolTables.size(); i++) {
          for (int j = 0; j < symbolTables.get(i).getMethods().size(); j++) {
            if (symbolTables.get(i).getMethods().get(j).getName().equals(child_name)) {
              method_type = symbolTables.get(i).getMethods().get(j).getType();
            }
          }
        }
        if (method_type == "") { //check imports
          for (int i = 0; i < symbolTables.size(); i++) {
            for (int j = 0; j < symbolTables.get(i).getImports().size(); j++) {
              if (symbolTables.get(i).getImports().get(j).get("methodName").get(0) != null) {
                if (symbolTables.get(i).getImports().get(j).get("methodName").get(0).equals(child_name)) {
                  method_type = symbolTables.get(i).getImports().get(j).get("returnType").get(0);
                }
              }
            }
          }
        }
        if (method_type != "Boolean")
          errors.add("ERROR: Not operator is not used on a boolean expression.");
        return;
      }
    }
  errors.add("ERROR: Not operator is not used on a boolean expression.");
  }

}
/* JavaCC - OriginalChecksum=67615bb47a512ad075453a1e6653f945 (do not edit this line) */
